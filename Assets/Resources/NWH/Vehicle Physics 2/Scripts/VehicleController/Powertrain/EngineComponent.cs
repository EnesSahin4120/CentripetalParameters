using System;
using System.Collections.Generic;
using NWH.Common.Utility;
using UnityEngine;
using UnityEngine.Events;
using NWH.Common.Vehicles;

#if UNITY_EDITOR
using UnityEditor;
using NWH.NUI;
#endif

namespace NWH.VehiclePhysics2.Powertrain
{
    [Serializable]
    public partial class EngineComponent : PowertrainComponent
    {
        public delegate float CalculateTorque(float angularVelocity, float dt);

        /// <summary>
        ///     Delegate for a function that modifies engine power.
        /// </summary>
        public delegate float PowerModifier();

        public enum EngineType
        {
            ICE,
            Electric,
        }

        /// <summary>
        ///     If true starter will be ran for [starterRunTime] seconds if engine receives any throttle input.
        /// </summary>
        [Tooltip("    If true starter will be ran for [starterRunTime] seconds if engine receives any throttle input.")]
        public bool autoStartOnThrottle = true;

        /// <summary>
        ///     Assign your own delegate to use different type of torque calculation.
        /// </summary>
        [Tooltip("    Assign your own delegate to use different type of torque calculation.")]
        public CalculateTorque calculateTorqueDelegate;

        /// <summary>
        ///     Engine type. ICE (Internal Combustion Engine) supports features such as starter, stalling, etc.
        ///     Electric engine (motor) can run in reverse, can not be stalled and does not use starter.
        /// </summary>
        [Tooltip(
            "Engine type. ICE (Internal Combustion Engine) supports features such as starter, stalling, etc.\r\nElectric engine (motor) can run in reverse, can not be stalled and does not use starter.")]
        [ShowInTelemetry]
        [ShowInSettings]
        public EngineType engineType = EngineType.ICE;

        /// <summary>
        ///     Turbocharger or supercharger.
        /// </summary>
        [Tooltip("    Turbocharger or supercharger.")]
        public ForcedInduction forcedInduction = new ForcedInduction();

        /// <summary>
        ///     Power generated by the engine in kW
        /// </summary>

        [Tooltip("    Power generated by the engine in kW")]
        [ShowInTelemetry]
        [NonSerialized]
        public float generatedPower;

        /// <summary>
        ///     RPM at which idler circuit will try to keep RPMs when there is no input.
        /// </summary>
        [SerializeField]
        [Tooltip("    RPM at which idler circuit will try to keep RPMs when there is no input.")]
        public float idleRPM = 900;

        /// <summary>
        ///     Is the ignition on? If off engine will refuse to start and run.
        /// </summary>
        [Tooltip("    Is the ignition on? If off engine will refuse to start and run.")]
        [ShowInTelemetry]
        public bool ignition = true;

        /// <summary>
        ///     Is the engine stalling? Stalling will happen if engine RPM is lower than stall RPM.
        /// </summary>
        [Tooltip("    Is the engine stalling? Stalling will happen if engine RPM is lower than stall RPM.")]
        [NonSerialized] 
        public bool isStalling;

        /// <summary>
        ///     Current loss torque. Pumping losses, friction, etc.
        /// </summary>
        [Tooltip("    Current loss torque. Pumping losses, friction, etc.")]
        [NonSerialized]
        [ShowInTelemetry]
        public float lossTorque;

        /// <summary>
        ///     Torque representing losses in the engine.
        ///     Higher value will result in engine slowing down faster.
        /// </summary>
        [Tooltip(
            "    Torque representing losses in the engine.\r\n    Higher value will result in engine slowing down faster.")]
        public float maxLossTorque = 100f;

        /// <summary>
        ///     Maximum engine power in [kW].
        /// </summary>
        [Tooltip("    Maximum engine power in [kW].")]
        [ShowInSettings("Max. Power", 20, 400, 10)]
        public float maxPower = 120;

        /// <summary>
        ///     Maximum engine RPM. This is a hard limit set in solver that the engine will never be able to go over.
        ///     Differs from rev limiter RPM and should always be higher than rev limiter.
        /// </summary>
        [Tooltip(
            "Maximum engine RPM. This is a hard limit set in solver that the engine will never be able to go over.\r\nDiffers from rev limiter RPM and should always be higher than rev limiter.")]
        public float maxRPM = 5000;

        /// <summary>
        ///     Minimum engine RPM. Hard limit set in solver that the engine will never go under.
        ///     It is recommended to set it to a negative value as otherwise the engine will always have RPM >0.
        /// </summary>
        [Tooltip(
            "Minimum engine RPM. Hard limit set in solver that the engine will never go under.\r\nIt is recommended to set it to a negative value as otherwise the engine will always have RPM >0.")]
        public float minRPM = -50;

        /// <summary>
        ///     Called when engine hits rev limiter.
        /// </summary>
        [Tooltip("    Called when engine hits rev limiter.")]
        public UnityEvent onRevLimiter = new UnityEvent();

        /// <summary>
        ///     Called when engine is started.
        /// </summary>
        [Tooltip("    Called when engine is started.")]
        public UnityEvent OnStart = new UnityEvent();

        /// <summary>
        ///     Called when engine is stopped.
        /// </summary>
        [Tooltip("    Called when engine is stopped.")]
        public UnityEvent OnStop = new UnityEvent();

        /// <summary>
        ///     If true the engine will be started immediately, without running the starter, when the vehicle is enabled.
        ///     Sets engine angular velocity to idle angular velocity.
        /// </summary>
        [Tooltip(
            "If true the engine will be started immediately, without running the starter, when the vehicle is enabled.\r\nSets engine angular velocity to idle angular velocity.")]
        public bool flyingStartEnabled;

        /// <summary>
        ///     Power curve with RPM range [0,1] on the X axis and power coefficient [0,1] on Y axis.
        ///     Both values are represented as percentages and should be in 0 to 1 range.
        ///     Power coefficient is multiplied by maxPower to get the final power at given RPM.
        /// </summary>
        [Tooltip(
            "Power curve with RPM range [0,1] on the X axis and power coefficient [0,1] on Y axis.\r\nBoth values are represented as percentages and should be in 0 to 1 range.\r\nPower coefficient is multiplied by maxPower to get the final power at given RPM.")]
        public AnimationCurve powerCurve;

        /// <summary>
        ///     List of callbacks that influence engine power. Examples would be traction control which
        ///     reduces power (returns less than 1) or forced induction which increases power (returns more than 1).
        ///     Can also be used by modules to reduce engine power in certain situations.
        ///     Final power modifier value is calculated by multiplying return values of all callbacks.
        /// </summary>
        [Tooltip(
            "List of callbacks that influence engine power. Examples would be traction control which\r\nreduces power (returns less than 1) or forced induction which increases power (returns more than 1).\r\nCan also be used by modules to reduce engine power in certain situations.\r\nFinal power modifier value is calculated by multiplying return values of all callbacks.")]
        [NonSerialized] public List<PowerModifier> powerModifiers = new List<PowerModifier>();

        /// <summary>
        ///     Is the engine currently hitting the rev limiter?
        /// </summary>
        [Tooltip("    Is the engine currently hitting the rev limiter?")]
        [NonSerialized] public bool revLimiterActive;

        /// <summary>
        ///     If engine RPM rises above revLimiterRPM, how long should fuel cutoff last?
        ///     Higher values make hitting rev limiter more rough and choppy.
        /// </summary>
        [Tooltip(
            "If engine RPM rises above revLimiterRPM, how long should fuel cutoff last?\r\nHigher values make hitting rev limiter more rough and choppy.")]
        public float revLimiterCutoffDuration;

        /// <summary>
        ///     Should engine use rev limiter? If disabled engine will be able to rotate up to maxRPM which is
        ///     the hard limit for the solver.
        /// </summary>
        [Tooltip(
            "Should engine use rev limiter? If disabled engine will be able to rotate up to maxRPM which is\r\nthe hard limit for the solver.")]
        public bool revLimiterEnabled = true;

        /// <summary>
        ///     Engine RPM at which rev limiter activates.
        /// </summary>
        [Tooltip("    Engine RPM at which rev limiter activates.")]
        public float revLimiterRPM = 4700;

        /// <summary>
        ///     Can the vehicle be stalled?
        ///     If disabled engine will run no matter the RPM. Automatically disabled when electric engine type is used.
        /// </summary>
        [Tooltip(
            "Can the vehicle be stalled?\r\nIf disabled engine will run no matter the RPM. Automatically disabled when electric engine type is used.")]
        public bool stallingEnabled = true;

        /// <summary>
        ///     Engine RPM under which the engine stalls.
        /// </summary>
        [Tooltip("    Engine RPM under which the engine stalls.")]
        public float stallRPM = 300;

        /// <summary>
        ///     Is the starter currently active?
        /// </summary>
        [Tooltip("    Is the starter currently active?")]
        [NonSerialized]
        [ShowInTelemetry]
        public bool starterActive;

        /// <summary>
        ///     Maximum RPM the starter motor alone can achieve when spinning up the engine.
        ///     If set too low the engine may fail to start (depending on stall RPM and loss torque).
        /// </summary>
        [Tooltip(
            "Maximum RPM the starter motor alone can achieve when spinning up the engine.\r\nIf set too low the engine may fail to start (depending on stall RPM and loss torque).")]
        public float starterRPMLimit = 600;

        /// <summary>
        ///     How long will the starter run after it is triggered.
        /// </summary>
        [Tooltip("    How long will the starter run after it is triggered.")]
        public float starterRunTime = 1f;

        /// <summary>
        ///     Torque starter motor can put out. Make sure that this torque is more than loss torque
        ///     at the starter RPM limit. If too low the engine will fail to start.
        /// </summary>
        [Tooltip(
            "Torque starter motor can put out. Make sure that this torque is more than loss torque\r\nat the starter RPM limit. If too low the engine will fail to start.")]
        public float starterTorque = 60f;

        private float _throttlePosition = 1f;
        private float _idleAngularVelocity;
        private float _maxAngularVelocity;
        private float _minAngularVelocity;
        private float _revLimiterAngularVelocity;
        private float _revLimiterStartTime;
        private float _stallAngularVelocity;
        private float _starterMaxAngularVelocity;
        private float _starterTimer;
        private bool _wasRunning;

        /// <summary>
        /// Peak power as calculated from the power curve. If the power curve peaks at Y=1 peak power will equal max power field value.
        /// After changing power, power curve or RPM range call UpdatePeakPowerAndTorque() to get update the value.
        /// </summary>
        public float PeakPower
        {
            get { return _peakPower; }
        }

        /// <summary>
        /// RPM at which the peak power is achieved.
        /// After changing power, power curve or RPM range call UpdatePeakPowerAndTorque() to get update the value.
        /// </summary>
        public float PeakPowerRPM
        {
            get { return _peakPowerRpm; }
        }

        /// <summary>
        /// Peak torque value as calculated from the power curve.
        /// After changing power, power curve or RPM range call UpdatePeakPowerAndTorque() to get update the value.
        /// </summary>
        public float PeakTorque
        {
            get { return _peakTorque; }
        }

        /// <summary>
        /// RPM at which the engine achieves the peak torque, calculated from the power curve.
        /// After changing power, power curve or RPM range call UpdatePeakPowerAndTorque() to get update the value.
        /// </summary>
        public float PeakTorqueRPM
        {
            get { return _peakTorqueRpm; }
        }

        private float _peakPower;
        private float _peakPowerRpm;
        private float _peakTorque;
        private float _peakTorqueRpm;
        private float _powerModifierSum;

        /// <summary>
        ///     Torque generated by the engine.
        /// </summary>
        public float GeneratedTorque { get; private set; }

        /// <summary>
        ///     Angular velocity at idle.
        /// </summary>
        public float IdleAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(idleRPM); }
        }

        /// <summary>
        ///     Is the engine running?
        /// </summary>
        public bool IsRunning
        {
            get { return ignition && (engineType == EngineType.Electric || _angularVelocity > _stallAngularVelocity); }
        }

        /// <summary>
        ///     Maximum  angular velocity the engine can physically achieve.
        /// </summary>
        public float MaxAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(maxRPM); }
        }

        /// <summary>
        ///     Minimum angular velocity the engine can physically achieve.
        /// </summary>
        public float MinAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(minRPM); }
        }

        /// <summary>
        ///     Angular velocity at which the rev limiter activates.
        /// </summary>
        public float RevLimiterAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(revLimiterRPM); }
        }

        /// <summary>
        ///     RPM as a percentage of maximum RPM.
        /// </summary>
        public float RPMPercent
        {
            get { return Mathf.Clamp01(RPM / revLimiterRPM); }
        }

        /// <summary>
        ///     Angular velocity at which the engine stalls.
        /// </summary>
        public float StallAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(stallRPM); }
        }

        /// <summary>
        ///     Maximum angular velocity the starter can spin the engine to.
        /// </summary>
        public float StarterMaxAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(starterRPMLimit); }
        }

        /// <summary>
        ///     Engine throttle position. 0 for no throttle and 1 for full throttle.
        /// </summary>
        [ShowInTelemetry]
        public float ThrottlePosition
        {
            get { return _throttlePosition; }
            set { _throttlePosition = Mathf.Clamp01(value); }
        }


        public override void Initialize(VehicleController vc)
        {
            base.Initialize(vc);

            if (OnStart == null)
            {
                OnStart = new UnityEvent();
            }

            if (OnStop == null)
            {
                OnStop = new UnityEvent();
            }

            if (onRevLimiter == null)
            {
                onRevLimiter = new UnityEvent();
            }

            _revLimiterStartTime = -999f;

            if (engineType == EngineType.Electric)
            {
                revLimiterCutoffDuration = 0f;
                stallingEnabled = false;
                idleRPM = 0f;
                minRPM = 0f;
                maxRPM = revLimiterRPM;
                starterActive = false;
                starterRunTime = 0f;
                ignition = true;
                isStalling = false;
                stallRPM = -Mathf.Infinity;
            }

            UpdatePeakPowerAndTorque();

            if (engineType == EngineType.ICE)
            {
                calculateTorqueDelegate = CalculateTorqueICE;
            }
            else if (engineType == EngineType.Electric)
            {
                calculateTorqueDelegate = CalculateTorqueElectric;
            }
        }


        /// <summary>
        ///     Starts the engine.
        /// </summary>
        public void StartEngine()
        {
            ignition = true;

            if (ComponentDamage < 1f && !IsRunning)
            {
                if (flyingStartEnabled)
                {
                    isStalling = false;
                    starterActive = false;
                    ignition = true;
                    _angularVelocity = UnitConverter.RPMToAngularVelocity(idleRPM);
                }
                else
                {
                    starterActive = true;
                }

                OnStart.Invoke();
            }
            else
            {
                starterActive = false;
            }
        }


        public override void OnPrePhysicsStep(float dt)
        {
            base.OnPrePhysicsStep(dt);

            if (ComponentDamage > 0.999f)
            {
                ignition = false;
            }

            if (vc.input.EngineStartStop)
            {
                StartStopEngine();
                vc.input.EngineStartStop = false;
            }

            // Rev matching
            TransmissionComponent transmission = vc.powertrain.transmission;
            if (transmission.revMatch
                && transmission.IsShifting
                && transmission.LastGearShift.FromGear > 0
                && transmission.LastGearShift.ToGear > 0)
            {
                vc.powertrain.clutch.clutchEngagement = 0f;
                float iT = (transmission.LastGearShift.EndTime - vc.realtimeSinceStartup) /
                           (transmission.LastGearShift.EndTime - transmission.LastGearShift.StartTime);
                iT = iT < 0 ? 0 : iT > 1 ? 1 : iT;
                float fromRPM = transmission.LastGearShift.FromRpm;
                float toRPM = transmission.LastGearShift.ToRpm;

                if (toRPM > 0)
                {
                    _angularVelocity = UnitConverter.RPMToAngularVelocity(Mathf.Lerp(fromRPM, toRPM, 1f - iT));
                }
            }

            // Disable revving in neutral when automatic transmission
            _throttlePosition = vc.input.InputSwappedThrottle;


            maxRPM = revLimiterRPM * 1.2f;
            _maxAngularVelocity = MaxAngularVelocity;
            _minAngularVelocity = MinAngularVelocity;
            _idleAngularVelocity = IdleAngularVelocity;
            _stallAngularVelocity = StallAngularVelocity;
            _revLimiterAngularVelocity = RevLimiterAngularVelocity;
            _starterMaxAngularVelocity = StarterMaxAngularVelocity;

            _lowerAngularVelocityLimit = _minAngularVelocity;
            _upperAngularVelocityLimit = _maxAngularVelocity;

            if (engineType != EngineType.Electric)
            {
                // Check for auto-starter
                if (!IsRunning && !starterActive && autoStartOnThrottle && _throttlePosition > 0.5f &&
                    ComponentDamage < 0.999f)
                {
                    StartEngine();
                }

                // Check starter timer
                if (starterActive)
                {
                    _starterTimer += dt;
                    if (_starterTimer > starterRunTime)
                    {
                        starterActive = false;
                        _starterTimer = 0;
                    }
                }
            }
            else
            {
                _starterTimer = 0;
                starterActive = false;
                revLimiterCutoffDuration = 0f;
            }

            if (vc.powertrain.transmission.IsShifting)
            {
                _throttlePosition = 0f;
            }


            if (ComponentDamage > 0.999f || !ignition)
            {
                _throttlePosition = 0;
            }

            _powerModifierSum = SumPowerModifiers();

            if (engineType != EngineType.Electric)
            {
                forcedInduction.Update(this);
            }
        }


        public override void OnEnable()
        {
            base.OnEnable();

            if (flyingStartEnabled || _wasRunning)
            {
                StartEngine();
            }
        }


        public override void OnDisable()
        {
            base.OnDisable();

            generatedPower = 0;
            GeneratedTorque = 0;

            _wasRunning = IsRunning;
            if (IsRunning)
            {
                StopEngine();
            }
        }


        public override void SetDefaults(VehicleController vc)
        {
            base.SetDefaults(vc);

            inertia = 0.07f;
            forcedInduction = new ForcedInduction();
            powerCurve = new AnimationCurve
            {
                keys = new[]
                {
                    new Keyframe(0f,   0f,   0,  5f),
                    new Keyframe(0.25f, 0.7f, 1f, 1f),
                    new Keyframe(0.5f, 0.8f, 1f, 1f),
                    new Keyframe(1f,   1f),
                },
            };
            UpdatePeakPowerAndTorque();

            SetOutput(vc.powertrain.clutch);
        }


        public override void Validate(VehicleController vc)
        {
            base.Validate(vc);

            Debug.Assert(stallRPM < idleRPM, "Engine stall RPM is higher than idle RPM. Vehicle will always stall.");
            Debug.Assert(powerCurve.keys.Length > 1, "Engine power curve is not set up. Engine will not run.");
            Debug.Assert(!string.IsNullOrEmpty(outputASelector.name),
                         "Engine is not connected to anything. Go to Powertrain > Engine and set the output.");
        }


        public void UpdatePeakPowerAndTorque()
        {
            GetPeakPower(out _peakPower, out _peakPowerRpm);
            GetPeakTorque(out _peakTorque, out _peakTorqueRpm);
        }


        /// <summary>
        /// Toggles engine state.
        /// </summary>
        public void StartStopEngine()
        {
            if (IsRunning)
            {
                StopEngine();
            }
            else
            {
                StartEngine();
            }
        }


        /// <summary>
        ///     Calculates torque for electric engine type.
        /// </summary>
        public float CalculateTorqueElectric(float angularVelocity, float dt)
        {
            float generatedTorque = 0f;

            // Calculate power
            if (angularVelocity > -_revLimiterAngularVelocity && angularVelocity < _revLimiterAngularVelocity)
            {
                // Power in electric motor is ~linear with the RPM, while torque is ~constant.
                // Give it a bump in power at 0
                generatedPower = maxPower * RPMPercent * _throttlePosition * _powerModifierSum
                    + _throttlePosition * maxPower * 0.2f;
                generatedPower = Mathf.Clamp(generatedPower, -maxPower, maxPower);

                // Calculate torque before losses)
                float absAngVel = angularVelocity < 0f ? -angularVelocity : angularVelocity;
                generatedTorque = (generatedPower * 1000f) / (absAngVel < 10f ? 10f : angularVelocity);
            }
            else
            {
                generatedPower = 0f;
            }

            lossTorque = (1f - _throttlePosition) * maxLossTorque * RPMPercent;
            generatedTorque -= lossTorque;

            return generatedTorque;
        }


        /// <summary>
        ///     Calculates torque for ICE engine type.
        /// </summary>
        public float CalculateTorqueICE(float angularVelocity, float dt)
        {
            float t = vc.realtimeSinceStartup;

            _throttlePosition = starterActive ? 0 : _throttlePosition;

            if (angularVelocity < _idleAngularVelocity * 1.1f && angularVelocity > _stallAngularVelocity)
            {
                float idleCorrection = (angularVelocity - _idleAngularVelocity) * dt * 4f;
                idleCorrection = idleCorrection < -0.2f ? -0.2f : idleCorrection > 0.2f ? 0.2f : idleCorrection;
                _throttlePosition -= idleCorrection;
                _throttlePosition = _throttlePosition < 0f ? 0f : _throttlePosition > 1f ? 1f : _throttlePosition;
            }

            // Handle engine spinning is opposite direction
            if (angularVelocity < 0)
            {
                if (starterActive)
                {
                    this._angularVelocity = 0.001f;
                    return starterTorque;
                }

                return 0;
            }

            float generatedTorque = 0;

            // Calculate power

            // Rev limiter
            if (_revLimiterStartTime < 0f)
            {
                revLimiterActive = revLimiterEnabled && angularVelocity > _revLimiterAngularVelocity;
                if (revLimiterActive)
                {
                    _revLimiterStartTime = t;
                    onRevLimiter.Invoke();
                }
            }
            else if (t >= _revLimiterStartTime + revLimiterCutoffDuration)
            {
                revLimiterActive = false;
                _revLimiterStartTime = -999f;
            }

            if (revLimiterActive || vc.powertrain.transmission.IsShifting) // TODO - might not be connected to a transmission
            {
                generatedPower = 0f;
                _throttlePosition = 0f;
            }

            // Stalling
            isStalling = stallingEnabled && angularVelocity < _stallAngularVelocity;

            // Calculate power from RPM
            if (isStalling || revLimiterActive || !ignition)
            {
                generatedPower = 0f;
            }
            else
            {
                float angVelPercent = angularVelocity / _maxAngularVelocity;
                generatedPower = powerCurve.Evaluate(angVelPercent) * maxPower *
                                 _throttlePosition * _powerModifierSum * forcedInduction.PowerGainMultiplier;
            }

            // Calculate torque before losses
            // Cut off power below stall angular velocity to simulate CDI cutting spark
            generatedTorque =
                isStalling ? 0 : generatedPower * 1000f / (angularVelocity == 0 ? 0.1f : angularVelocity);

            // Calculate losses
            lossTorque = (1f - _throttlePosition) * maxLossTorque * RPMPercent;
            generatedTorque -= lossTorque;

            // Add starter torque
            if (starterActive && angularVelocity < _starterMaxAngularVelocity)
            {
                generatedTorque += starterTorque;
            }

            return generatedTorque;
        }


        public void GetPeakTorque(out float peakTorque, out float peakTorqueRpm)
        {
            peakTorque = 0;
            peakTorqueRpm = 0;

            for (float i = 0.05f; i < 1f; i += 0.05f)
            {
                float rpm = i * revLimiterRPM;
                float P = powerCurve.Evaluate(i) * maxPower;
                if (rpm < stallRPM)
                {
                    continue;
                }
                float W = UnitConverter.RPMToAngularVelocity(rpm);
                float T = (P * 1000f) / W;

                if (T > peakTorque)
                {

                    peakTorque = T;
                    peakTorqueRpm = rpm;
                }
            }

            float fiCoefficient = forcedInduction.useForcedInduction ? forcedInduction.powerGainMultiplier : 1f;
            peakTorque = peakTorque * fiCoefficient;
        }

        public void GetPeakPower(out float peakPower, out float peakPowerRpm)
        {
            float maxY = 0f;
            float maxX = 1f;
            for (float i = 0f; i < 1f; i += 0.05f)
            {
                float y = powerCurve.Evaluate(i);
                if (y > maxY)
                {
                    maxY = y;
                    maxX = i;
                }
            }

            float fiCoefficient = forcedInduction.useForcedInduction ? forcedInduction.powerGainMultiplier : 1f;
            peakPower = maxY * maxPower * fiCoefficient;
            peakPowerRpm = maxX * revLimiterRPM;
        }


        /// <summary>
        ///     Returns current engine load.
        /// </summary>
        /// <returns></returns>
        public float GetLoad()
        {
            float RPMCoeff = RPMPercent;
            float powerCoeff = generatedPower / maxPower;
            return Mathf.Clamp01(powerCoeff * 0.6f + RPMCoeff * 0.4f);
        }


        public void IntegrateDownwards(float dt)
        {
            if (_outputAIsNull)
            {
                return;
            }

            float Ia = inertia;
            float Ib = outputA.QueryInertia();
            float Isum = Ia + Ib;
            float Wa = _angularVelocity;
            float Wb = QueryAngularVelocity(_angularVelocity, dt);
            float Wtarget = Ia / Isum * Wa + Ib / Isum * Wb;
            float Winit = _angularVelocity;

            // Calculate generated torque
            GeneratedTorque = calculateTorqueDelegate(Wa, dt);

            // Calculate reaction torque
            float Treact = (Wtarget - Wa) * Ia / dt;
            float torqueCap = vc.powertrain.clutch.slipTorque * vc.powertrain.clutch.clutchEngagement;
            Treact = Treact < -torqueCap ? -torqueCap : Treact > torqueCap ? torqueCap : Treact;

            // Calculate/get torque returned from wheels
            float Treturned = ForwardStep(GeneratedTorque - Treact, 0, dt);

            _torque = GeneratedTorque + Treturned + Treact;
            _angularVelocity += _torque / Isum * dt;

        }


        public void StopEngine()
        {
            if (IsRunning)
            {
                ignition = false;
                OnStop.Invoke();
                _angularVelocity = 0;
            }
        }


        private float SumPowerModifiers()
        {
            if (powerModifiers.Count == 0)
            {
                return 1f;
            }

            float coefficient = 1;
            int n = powerModifiers.Count;
            for (int i = 0; i < n; i++)
            {
                coefficient *= powerModifiers[i].Invoke();
            }

            return Mathf.Clamp(coefficient, 0f, Mathf.Infinity);
        }
    }
}


#if UNITY_EDITOR
namespace NWH.VehiclePhysics2.Powertrain
{
    [CustomPropertyDrawer(typeof(EngineComponent))]
    public partial class EngineComponentDrawer : PowertrainComponentDrawer
    {
        private EngineComponent _engineComponent;

        public override bool OnNUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (!base.OnNUI(position, property, label))
            {
                return false;
            }

            DrawCommonProperties();

            _engineComponent =
                SerializedPropertyHelper.GetTargetObjectOfProperty(property) as EngineComponent;

            int typeEnumValue = property.FindPropertyRelative("engineType").enumValueIndex;
            bool isElectric = typeEnumValue == (int)EngineComponent.EngineType.Electric;

            drawer.BeginSubsection("General");
            drawer.Field("engineType", !Application.isPlaying);

            if (!isElectric)
            {
                if (drawer.Field("stallingEnabled").boolValue)
                {
                    drawer.Field("stallRPM", true, "rpm");
                }
            }

            drawer.Field("ignition");
            if (!isElectric)
            {
                drawer.Field("autoStartOnThrottle");
            }

            drawer.EndSubsection();


            drawer.BeginSubsection("Power & Torque");
            EditorGUI.BeginChangeCheck();
            drawer.Field("maxPower", true, "kW");
            drawer.Field("maxLossTorque", true, "Nm");

            if (!isElectric)
            {
                drawer.Field("powerCurve");
            }
            else
            {
                drawer.Info("Electric engine is using a fixed linear power curve.");
            }

            drawer.Space(5);

            _engineComponent.UpdatePeakPowerAndTorque();

            GUI.enabled = false;
            string fiString = _engineComponent.forcedInduction.useForcedInduction
                                  ? "(including +" + ((_engineComponent.forcedInduction.powerGainMultiplier - 1f) * 100f).ToString(
                                        "F0") + "% from FI)"
                                  : "";
            drawer.Label($"Peak Power:\t{_engineComponent.PeakPower.ToString("F0")}kw " +
                         $"@ {_engineComponent.PeakPowerRPM.ToString("F0")}RPM {fiString}");

            if (!isElectric)
            {
                drawer.Label($"Peak Torque:\t{_engineComponent.PeakTorque.ToString("F0")}Nm " +
                    $"@ {_engineComponent.PeakTorqueRPM.ToString("F0")}RPM");
            }

            drawer.Info("Peak power and torque values are calculated from Power Curve, Max Power, Forced Induction and RPM settings.");
            GUI.enabled = true;

            drawer.EndSubsection();

            if (!isElectric)
            {
                drawer.BeginSubsection("Starter");
                drawer.Field("starterRunTime", true, "s");
                drawer.Field("starterRPMLimit", true, "rpm");
                drawer.Field("starterTorque", true, "Nm");
                drawer.EndSubsection();

                drawer.BeginSubsection("Flying StartEngine");
                drawer.Field("flyingStartEnabled");
                drawer.EndSubsection();

                drawer.BeginSubsection("Idler Circuit");
                drawer.Field("idleRPM");
                drawer.EndSubsection();
            }

            drawer.BeginSubsection("Rev Limiter");
            if (drawer.Field("revLimiterEnabled").boolValue)
            {
                drawer.Field("revLimiterRPM");
                drawer.Field("revLimiterCutoffDuration");
            }

            drawer.EndSubsection();

            if (!isElectric)
            {
                drawer.BeginSubsection("Forced Induction");
                drawer.Property("forcedInduction");
                drawer.EndSubsection();
            }

            drawer.BeginSubsection("Events");
            drawer.Field("OnStart");
            drawer.Field("OnStop");
            drawer.Field("onRevLimiter");
            drawer.EndSubsection();

            drawer.EndProperty();
            return true;
        }
    }
}

#endif
